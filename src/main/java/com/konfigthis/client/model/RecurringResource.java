/*
 * External API
 *   # Developer Resources  Refer [Developer Resources](https://developer.paychex.com/resources/overview/) for more details on API specification 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.Link;
import com.konfigthis.client.model.PayComponentFrequencyTypeResource1;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * Worker recurring deduction
 */
@ApiModel(description = "Worker recurring deduction")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class RecurringResource {
  public static final String SERIALIZED_NAME_WORKER_COMPONENT_ID = "workerComponentId";
  @SerializedName(SERIALIZED_NAME_WORKER_COMPONENT_ID)
  private String workerComponentId;

  public static final String SERIALIZED_NAME_COMPONENT_ID = "componentId";
  @SerializedName(SERIALIZED_NAME_COMPONENT_ID)
  private String componentId;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * The type of calculation that will be applied for the pay component .
   */
  @JsonAdapter(CalculationTypeEnum.Adapter.class)
 public enum CalculationTypeEnum {
    FLAT_DOLLAR_AMOUNT_THIS_IS_USED_FOR_A_SPECIFIC_DOLLAR_AMOUNT("FLAT_DOLLAR_AMOUNT:This is used for a specific dollar amount"),
    
    PERCENTAGE_THIS_IS_USED_FOR_WHEN_A_PERCENTAGE_WILL_BE_USED_TO_CALCULATE_THE_AMOUNT_AND_WILL_NEED_A_CALCULATIONBASEID_TO_SPECIFY_WHAT_TO_APPLY_AGAINST("PERCENTAGE:This is used for when a Percentage will be used to calculate the amount and will need a calculationBaseId to specify what to apply against"),
    
    RATE_X_UNITS_THIS_IS_USED_FOR_APPLY_THE_RATE_AGAINST_UNITS_AND_WILL_NEED_A_CALCULATIONBASEID_TO_SPECIFY_WHAT_TO_APPLY_AGAINST("RATE_X_UNITS:This is used for apply the rate against units and will need a calculationBaseId to specify what to apply against"),
    
    RATE_X_HOURS_THIS_IS_USED_FOR_APPLY_THE_RATE_AGAINST_HOURS_AND_WILL_NEED_A_CALCULATIONBASEID_TO_SPECIFY_WHAT_TO_APPLY_AGAINST_("RATE_X_HOURS:This is used for apply the rate against hours and will need a calculationBaseId to specify what to apply against.");

    private String value;

    CalculationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CalculationTypeEnum fromValue(String value) {
      for (CalculationTypeEnum b : CalculationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CalculationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CalculationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CalculationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CalculationTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CALCULATION_TYPE = "calculationType";
  @SerializedName(SERIALIZED_NAME_CALCULATION_TYPE)
  private CalculationTypeEnum calculationType;

  public static final String SERIALIZED_NAME_CALCULATION_BASE_ID = "calculationBaseId";
  @SerializedName(SERIALIZED_NAME_CALCULATION_BASE_ID)
  private String calculationBaseId;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private Double value;

  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_EFFECTIVE_DATE = "effectiveDate";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_DATE)
  private OffsetDateTime effectiveDate;

  public static final String SERIALIZED_NAME_END_DATE = "endDate";
  @SerializedName(SERIALIZED_NAME_END_DATE)
  private OffsetDateTime endDate;

  public static final String SERIALIZED_NAME_EFFECT_ON_PAY = "effectOnPay";
  @SerializedName(SERIALIZED_NAME_EFFECT_ON_PAY)
  private String effectOnPay;

  public static final String SERIALIZED_NAME_CLASSIFICATION_TYPE = "classificationType";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION_TYPE)
  private String classificationType;

  public static final String SERIALIZED_NAME_FREQUENCY = "frequency";
  @SerializedName(SERIALIZED_NAME_FREQUENCY)
  private PayComponentFrequencyTypeResource1 frequency;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<Link> links = null;

  public RecurringResource() {
  }

  
  public RecurringResource(
     String workerComponentId
  ) {
    this();
    this.workerComponentId = workerComponentId;
  }

   /**
   * The id of a single pay component that a workers has.
   * @return workerComponentId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "970000223656831", value = "The id of a single pay component that a workers has.")

  public String getWorkerComponentId() {
    return workerComponentId;
  }




  public RecurringResource componentId(String componentId) {
    
    
    
    
    this.componentId = componentId;
    return this;
  }

   /**
   * The unique identifier of the pay component. This data field cannot be PATCHED.
   * @return componentId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "970000180599325", value = "The unique identifier of the pay component. This data field cannot be PATCHED.")

  public String getComponentId() {
    return componentId;
  }


  public void setComponentId(String componentId) {
    
    
    
    this.componentId = componentId;
  }


  public RecurringResource name(String name) {
    
    
    
    
    this.name = name;
    return this;
  }

   /**
   * Name of the pay component. This data field will be populated automatically based on componentId.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Deduction - 1", value = "Name of the pay component. This data field will be populated automatically based on componentId.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    
    
    
    this.name = name;
  }


  public RecurringResource calculationType(CalculationTypeEnum calculationType) {
    
    
    
    
    this.calculationType = calculationType;
    return this;
  }

   /**
   * The type of calculation that will be applied for the pay component .
   * @return calculationType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "00H2A1IUJE7MXV6TQ37U", value = "The type of calculation that will be applied for the pay component .")

  public CalculationTypeEnum getCalculationType() {
    return calculationType;
  }


  public void setCalculationType(CalculationTypeEnum calculationType) {
    
    
    
    this.calculationType = calculationType;
  }


  public RecurringResource calculationBaseId(String calculationBaseId) {
    
    
    
    
    this.calculationBaseId = calculationBaseId;
    return this;
  }

   /**
   * This is required if you are not using a FLAT_DOLLAR_AMOUNT Calculation Type.
   * @return calculationBaseId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "00H2A1IUJE7MXV6TQ37U", value = "This is required if you are not using a FLAT_DOLLAR_AMOUNT Calculation Type.")

  public String getCalculationBaseId() {
    return calculationBaseId;
  }


  public void setCalculationBaseId(String calculationBaseId) {
    
    
    
    this.calculationBaseId = calculationBaseId;
  }


  public RecurringResource value(Double value) {
    
    
    
    
    this.value = value;
    return this;
  }

  public RecurringResource value(Integer value) {
    
    
    
    
    this.value = value.doubleValue();
    return this;
  }

   /**
   * This is used to specify the value that is used against the calculationType.
   * @return value
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "5", value = "This is used to specify the value that is used against the calculationType.")

  public Double getValue() {
    return value;
  }


  public void setValue(Double value) {
    
    
    
    this.value = value;
  }


  public RecurringResource startDate(OffsetDateTime startDate) {
    
    
    
    
    this.startDate = startDate;
    return this;
  }

   /**
   * Date which this pay component will start to be applied during the payruns. This is an optional field that default to current datetime if not provided. This cannot be backdated but can be added to start in the future.
   * @return startDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2018-03-01T00:00Z", value = "Date which this pay component will start to be applied during the payruns. This is an optional field that default to current datetime if not provided. This cannot be backdated but can be added to start in the future.")

  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    
    
    
    this.startDate = startDate;
  }


  public RecurringResource effectiveDate(OffsetDateTime effectiveDate) {
    
    
    
    
    this.effectiveDate = effectiveDate;
    return this;
  }

   /**
   * Date which this pay component has started for the worker.
   * @return effectiveDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Date which this pay component has started for the worker.")

  public OffsetDateTime getEffectiveDate() {
    return effectiveDate;
  }


  public void setEffectiveDate(OffsetDateTime effectiveDate) {
    
    
    
    this.effectiveDate = effectiveDate;
  }


  public RecurringResource endDate(OffsetDateTime endDate) {
    
    
    
    
    this.endDate = endDate;
    return this;
  }

   /**
   * Date which this pay component has ended for the worker.
   * @return endDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Date which this pay component has ended for the worker.")

  public OffsetDateTime getEndDate() {
    return endDate;
  }


  public void setEndDate(OffsetDateTime endDate) {
    
    
    
    this.endDate = endDate;
  }


  public RecurringResource effectOnPay(String effectOnPay) {
    
    
    
    
    this.effectOnPay = effectOnPay;
    return this;
  }

   /**
   * What the effect on pay will be (REDUCTION OR ADDITION), currently only reductions are available. This data field will be populated automatically based on componentId. This data field cannot be PATCHED
   * @return effectOnPay
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "REDUCTION", value = "What the effect on pay will be (REDUCTION OR ADDITION), currently only reductions are available. This data field will be populated automatically based on componentId. This data field cannot be PATCHED")

  public String getEffectOnPay() {
    return effectOnPay;
  }


  public void setEffectOnPay(String effectOnPay) {
    
    
    
    this.effectOnPay = effectOnPay;
  }


  public RecurringResource classificationType(String classificationType) {
    
    
    
    
    this.classificationType = classificationType;
    return this;
  }

   /**
   * The category that this component falls into.
   * @return classificationType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The category that this component falls into.")

  public String getClassificationType() {
    return classificationType;
  }


  public void setClassificationType(String classificationType) {
    
    
    
    this.classificationType = classificationType;
  }


  public RecurringResource frequency(PayComponentFrequencyTypeResource1 frequency) {
    
    
    
    
    this.frequency = frequency;
    return this;
  }

   /**
   * Get frequency
   * @return frequency
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PayComponentFrequencyTypeResource1 getFrequency() {
    return frequency;
  }


  public void setFrequency(PayComponentFrequencyTypeResource1 frequency) {
    
    
    
    this.frequency = frequency;
  }


  public RecurringResource links(List<Link> links) {
    
    
    
    
    this.links = links;
    return this;
  }

  public RecurringResource addLinksItem(Link linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<Link> getLinks() {
    return links;
  }


  public void setLinks(List<Link> links) {
    
    
    
    this.links = links;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the RecurringResource instance itself
   */
  public RecurringResource putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RecurringResource recurringResource = (RecurringResource) o;
    return Objects.equals(this.workerComponentId, recurringResource.workerComponentId) &&
        Objects.equals(this.componentId, recurringResource.componentId) &&
        Objects.equals(this.name, recurringResource.name) &&
        Objects.equals(this.calculationType, recurringResource.calculationType) &&
        Objects.equals(this.calculationBaseId, recurringResource.calculationBaseId) &&
        Objects.equals(this.value, recurringResource.value) &&
        Objects.equals(this.startDate, recurringResource.startDate) &&
        Objects.equals(this.effectiveDate, recurringResource.effectiveDate) &&
        Objects.equals(this.endDate, recurringResource.endDate) &&
        Objects.equals(this.effectOnPay, recurringResource.effectOnPay) &&
        Objects.equals(this.classificationType, recurringResource.classificationType) &&
        Objects.equals(this.frequency, recurringResource.frequency) &&
        Objects.equals(this.links, recurringResource.links)&&
        Objects.equals(this.additionalProperties, recurringResource.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(workerComponentId, componentId, name, calculationType, calculationBaseId, value, startDate, effectiveDate, endDate, effectOnPay, classificationType, frequency, links, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RecurringResource {\n");
    sb.append("    workerComponentId: ").append(toIndentedString(workerComponentId)).append("\n");
    sb.append("    componentId: ").append(toIndentedString(componentId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    calculationType: ").append(toIndentedString(calculationType)).append("\n");
    sb.append("    calculationBaseId: ").append(toIndentedString(calculationBaseId)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    effectiveDate: ").append(toIndentedString(effectiveDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    effectOnPay: ").append(toIndentedString(effectOnPay)).append("\n");
    sb.append("    classificationType: ").append(toIndentedString(classificationType)).append("\n");
    sb.append("    frequency: ").append(toIndentedString(frequency)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("workerComponentId");
    openapiFields.add("componentId");
    openapiFields.add("name");
    openapiFields.add("calculationType");
    openapiFields.add("calculationBaseId");
    openapiFields.add("value");
    openapiFields.add("startDate");
    openapiFields.add("effectiveDate");
    openapiFields.add("endDate");
    openapiFields.add("effectOnPay");
    openapiFields.add("classificationType");
    openapiFields.add("frequency");
    openapiFields.add("links");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to RecurringResource
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!RecurringResource.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RecurringResource is not found in the empty JSON string", RecurringResource.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("workerComponentId") != null && !jsonObj.get("workerComponentId").isJsonNull()) && !jsonObj.get("workerComponentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workerComponentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workerComponentId").toString()));
      }
      if ((jsonObj.get("componentId") != null && !jsonObj.get("componentId").isJsonNull()) && !jsonObj.get("componentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `componentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("componentId").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("calculationType") != null && !jsonObj.get("calculationType").isJsonNull()) && !jsonObj.get("calculationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `calculationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("calculationType").toString()));
      }
      if ((jsonObj.get("calculationBaseId") != null && !jsonObj.get("calculationBaseId").isJsonNull()) && !jsonObj.get("calculationBaseId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `calculationBaseId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("calculationBaseId").toString()));
      }
      if ((jsonObj.get("effectOnPay") != null && !jsonObj.get("effectOnPay").isJsonNull()) && !jsonObj.get("effectOnPay").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `effectOnPay` to be a primitive type in the JSON string but got `%s`", jsonObj.get("effectOnPay").toString()));
      }
      if ((jsonObj.get("classificationType") != null && !jsonObj.get("classificationType").isJsonNull()) && !jsonObj.get("classificationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `classificationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("classificationType").toString()));
      }
      // validate the optional field `frequency`
      if (jsonObj.get("frequency") != null && !jsonObj.get("frequency").isJsonNull()) {
        PayComponentFrequencyTypeResource1.validateJsonObject(jsonObj.getAsJsonObject("frequency"));
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            Link.validateJsonObject(jsonArraylinks.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RecurringResource.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RecurringResource' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RecurringResource> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RecurringResource.class));

       return (TypeAdapter<T>) new TypeAdapter<RecurringResource>() {
           @Override
           public void write(JsonWriter out, RecurringResource value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public RecurringResource read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             RecurringResource instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RecurringResource given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RecurringResource
  * @throws IOException if the JSON string is invalid with respect to RecurringResource
  */
  public static RecurringResource fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RecurringResource.class);
  }

 /**
  * Convert an instance of RecurringResource to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

